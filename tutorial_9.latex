\documentclass[a4paper]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{blindtext}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{booktabs}
\usepackage{float}
\usepackage[bookmarks=true]{hyperref}
\usepackage{bookmark}
\usepackage{bbm}
\usepackage{wrapfig}
\usepackage{tabularx}
\usepackage[autostyle=true]{csquotes}
\graphicspath{ {./images/} }
\usepackage[bottom=0.5cm, right=1.5cm, left=1.5cm, top=1.5cm]{geometry}

\newtheorem{theorem}{Theorem}
\newtheorem{exercise}{Exercise}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}[section]

\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\p}{\ensuremath{\mathbb{P}}}
\newcommand{\E}{\ensuremath{\mathbb{E}}}
\newcommand{\F}{\ensuremath{\mathcal{F}}}
\newcommand{\1}{\ensuremath{\mathbbm{1}}}
\newcommand{\B}{\ensuremath{\mathbbm{B}}}

\title{Tutorial 9 - Reliable Transport Protocols}
\author{Gidon Rosalki}
\date{2026-01-01}


\begin{document}
\maketitle
\noindent\textbf{Notice:} If you find any mistakes, please open an issue at \href{https://github.com/robomarvin1501/notes\_networking}{\texttt{https://github.com/robomarvin1501/notes\_networking}}
\section{Reliable Transport}\label{sec:reliable_transport} % (fold)
The concept is to provide the upper layer a service abstraction of a reliable channel, where no bits are corrupted or
lost, and all bits are delivered in order. In order for this to hold, we need to make the network reliable, and ensure
reliable communication over an unreliable / noisy channel. This naturally has costs, and other requirements, which will
be discussed. 

\section{First attempt}\label{sec:first_attempt} % (fold)
In order for the network to be reliable, we could add the feature that when a packet is seen by a switch, we check that
it reaches the next hop without corruptions, and if it is corrupted, then we resend. This has a few questions, what if 2
switches fail? Where must we buffer packets, and for how long? What is the resultant goodput, throughput, and packet
delay? Since the network is unreliable, the packets may be delayed, lost, or corrupted. We thus need a mechanism to
monitor any of these. \\ 
% section First attempt (end)

For the purposes of today, we are going to assume that we can always detect errors, that each sender always has packets
to transmit, and packets are received in the order in which they are sent, without bypassing.
% section Reliable transport (end)


\section{Stop and Wait}\label{sec:stop_and_wait} % (fold)
This is split into two sides, the sender, and receiver. \\ 
The \textbf{sender} sends a packet, adn starts a timer. It waits for $T_{out}$ (timeout) units, to receive an ACK / NACK
response. If it receives NACK (not acknowledged), or the timeout is reached, then it resends, and resets the timer. If
it receives ACK, then it sends the next packet, and resets the timeout. \\ 
The \textbf{receiver} will send an ACK if it receives a packet, without an error, and NACK (or ignore) if the packet is
corrupted. For our purposes, we will probably ignore NACKs, since it only mildly improves the speeds offered by the
sender, letting the sender reach timeout is just as effective. 

This is not quite sufficient, since the receiver cannot distinguish between a new message, and a resent message. We can
try and resolve this, by adding a binary counter in the sent packets. \\
This is also not sufficient, since now the sender does not know which packet was ACKed. To resolve this, we also add a
binary counter in the ACKs sent by the receiver. 

The timer is initialised after sending the last bit of the packet, but we need to decide what is the minimal timeout
$T_{out}$ needed for this protocol to work. We need to consider: \begin{itemize}
    \item Packet siize 
    \item ACK / NACK size 
    \item Transmission rate (bandwidth)
    \item Distance between stations
    \item Propagation speed
    \item Processing time ($T_{pt}$) (unless told otherwise, only the receiver can have $T_{pt}>0$)
\end{itemize}
In order to calculate the timout, we will first note that we only care about the time from the last sent bit, and the
\textit{worst} case ACK / packet size. 
\begin{figure}[H]
    \center
    \includegraphics[scale=0.2]{tutorial_9_timeout_size.png}
    \caption{Timeout size}
\end{figure}
So we can see that \[T_{out} \geq 2T_{prop} + T_{ack} + T_{pt}\] 

\begin{example}[]
    Let:
    \begin{itemize}
        \item Packet size: 2000 bit
        \item ACK/NACK size: 200 bit
        \item Transmission rate (BW): 10 Kbps
        \item Distance between stations: 1000 km
        \item Propagation speed: 2 Â· 108m/s
        \item Processing time (Tpt ): 0 sec
        \item What is the minimal timeout, needed for this protocol?
    \end{itemize}

    \begin{proof}[Solution]
        We will note that the propagation speed is \begin{align*}
            T_{prop} &= \displaystyle\frac{\text{distance}}{\text{propagation speed}} \\ 
                     &= \displaystyle\frac{10 ^ {6}m}{2 \cdot 10 ^ {8}\frac{m}{s}} \\ 
                     &= 5 \cdot 10 ^ {-3}s
        \end{align*}

        The ACK time is \begin{align*}
            T_{ack} &= \displaystyle\frac{\text{ACK size}}{\text{Transmission rate}} \\ 
                    &= \displaystyle\frac{200 bits}{10 ^ {4} \frac{b}{s}} \\ 
                    &= 2 \cdot 10 ^ {-2}s
        \end{align*}

        So \begin{align*}
            T_{prop} &= 5 \cdot 10 ^ {-3}s \\ 
            T_{ack} &= 2 \cdot 10 ^ {-2}s \\ 
            T_{pt} &= 0 \\ 
            T_{out} &\geq 2T_{prop} + T_{ack} + T_{pt}  \\ 
                    &= 2 \cdot 5 \cdot 10 ^ {-3} + 2 \cdot 10 ^ {-2} + 0 \\ 
                    &= 3 \cdot 10 ^ {-2} s
        \end{align*}

    \end{proof}
\end{example}

Let us now consider the goodput. Let us assume that we use the whole bandwidth, and on failure, the receiver does not
send NACK, but just ignores teh packet. Packets /ACKs fail with probability \[
    p \implies X \sim Geo \left(\left(1 - p\right) ^ {2}\right)
\]
The expected number of tries until success (i.e. all attempts except the last fail): \[
    \E \left[X\right] = \displaystyle\frac{1}{\left(1 - p\right) ^ {2}}
\]
The goodput is the ratio of effective transmission time, and total transmission time. Let $T_{packet}$ be the
transmission time of a data packet. So: \[
    \text{Goodput}  = \displaystyle\frac{T_{packet}}{\left(\frac{1}{\left(1 - p\right) ^ {2}} - 1\right)\left(T_{packet}
    + T_{out}\right)}
\]
If $T_{out}$ is set to teh minimal value that we previously calculated $T_{out} = 2T_{prop} + T_{ack} + T_{pt}$ then \[
    \text{Goodput} = \displaystyle\frac{T_{packet}}{\left(\frac{1}{\left(1 - p\right) ^ {2}} - 1\right)\left(T_{packet}
    + T_{out}\right)}
            = \displaystyle\frac{T_{packet} \left(1 - p\right) ^ {2}}{T_{packet} + T_{out}}
\]

We will note that doing this for \textit{every packet} is expensive for the goodput, neatly bringing us on to the next
section.
% section Stop and Wait (end)

\section{Go Back N (GBN)}\label{sec:go_back_n_gbn_} % (fold)
In Stop and Wait we waste time during the timeout period. We can use this time to send additional packets. We will
assume that the sender has a sliding window of size $N$. The sender will send $N$ packets one after the other, and if it
reaches a timeout, then it resends from the last known ACK. The receiver only sends ACKs for the packets within the
sequence. 

\textbf{Sender}: Window size of $N$ packets, and send at most $N$ unacknowledged packets. 
If a timeout occurs, resend all packets that have been sent but not yet acknowledged. 
$ACK \left(i\right)$ indicates that packets $1, 2 \dots, i$ have been received correctly (meaning that it is
cumulative). When an ACK is received, then the beginning of the window is moved to the next unacknowledged sequence
number. \\
\textbf{Receiver}: Has a window size of a \textit{single} packet, and if it receives a packet with sequence number $i$
correctly, and in order (which is to say, that the last packet delivered to the upper layer has a sequence number $i -
1$), then send $ACK(i)$, and deliver the data to the layer above. Otherwise the packet is corrupted, or not in order, so
discard it, and send ACK for the most recently received in order packet.

The sender has a timer for each transmitted packet, which is started after sending the final bit of a packet. \\ 

Consider if we have a window size of 8, and use 3 bits to represent it. We can then desynchronise if all 8 packets are
received, but all 8 ACKs are lost, since the sender will return to the beginning of the window, but the receiver will
assume that this is new data. We can resolve this by for a window size of $n$, we use $\left\lceil \log_2 \left(n\right)
\right\rceil  + 1$ bits to represent it. 

\subsection{Questions}\label{sub:questions} % (fold)
Given a network with 2 nodes, A and B, we assume:
\begin{itemize}
    \item Node A only sends data to B, B only ACKs to A
    \item No limit on buffers or sequence numbers
    \item The packet transmission ($T_{packet}$), propagation time ($T_{prop}$) and packet processing time ($T_{pt}$ )
        are constant
    \item ACKs are delivered without any errors and $T_{ack} = 0$
    \item $T_{out}$ is set to the minimal value that avoids unnecessary retransmissions
    \item $T_{out} = 2T_{prop} + T_{ack} + T_{pt}$
    \item Window size is equal to $T_{out} + 1$
\end{itemize}
\subsubsection{Question 1}\label{sec:question_} % (fold)

We will change the protocol as follows: \begin{itemize}
    \item When node A detects a failure, it re-transmits the failed packet $L$ times
    \item Node A activates the timeout only after the last packet was sent
    \item Node A will keep transmitting the $L$ packets even if got an ACK for one of them
    \item Node B will ACK the first packet and ignore all duplicates
\end{itemize}

Complete the diagram when $L = 2,\ T_{prop} = 2,\ T_{packet} = 1,\ T_{pt} = 1$, the transmissions of packet number 2
fail 3 times, and all other packets arrive successfully: 
\begin{figure}[H]
    \center
    \includegraphics[scale=0.2]{tutorial_9_gobackn_q1.png}
\end{figure}

\textit{ Sol. }We will firstly compute $T_{out} = 2T_{prop} + T_{ack} + T_{pt} = 2 \cdot 2 + 1 + 0 = 5$. This results in
a window size of 6. As can be seen, we wind up with the following answer 
\begin{figure}[H]
    \center
    \includegraphics[scale=0.2]{tutorial_9_gobackn_s1.png}
\end{figure}
% subsubsection Question 1 (end)

\subsubsection{Question 2}\label{sec:question_} % (fold)
For a given $L$, assume that packets fail with probability $p$. What is the probability to succeed with exactly $k$
retries, where each retry consists of $L$ packets? \\ 

\textit{ Sol. }\begin{gather}
    \text{First try: } p_0 = 1 - p \\
    \text{First retry: } p_1 = p \left(1 - p ^ {L}\right) \\
    \text{Second retry: } p_2 = p \cdot p ^ {L} \left(1 - p ^ {L}\right) \\
    k \text{ retries: } p_k = p \cdot \left(p ^ {L}\right) ^ {k - 1} \left(1 - p ^ {L}\right) \\
\end{gather}
% subsubsection Question 2 (end)

\subsubsection{Question 3}\label{sec:question_} % (fold)
Assuming that $T_{pt} = T_{ack} = 0$, ad the receiver is ready to acscept the packet, what is the expected time to
successfully transmit a pcaket?

\textit{ Sol. }\begin{gather}
    \text{First try: } t_0 = T_{packet} \\
    \text{One retry: } t_1 = T_{packet} + \left(T_{out} + L \cdot T_{packet}\right) \\
    k \text{ retries: } t_k = T_{packet} + \left(T_{out} + L \cdot T_{packet}\right) \cdot k \\
\end{gather}

The expected time is \[
    t_{avg} = \displaystyle\sum_{k = 0}^{\infty}t_k p_k = T_{packet} + \displaystyle\frac{p \left(T_{out} + L \cdot
    T_{packet}\right)}{1 - p ^ {L}} %TODO full computation 35
\]
% subsubsection Question 3 (end)

\subsubsection{Question 4}\label{sec:question_} % (fold)
What is the expected goodput of the protocol? 

\textit{ Sol. }
Let $a = \displaystyle\frac{T_{out} + T_{packet}}{T_{packet}}$

\[
    \text{Goodput} = \displaystyle\frac{T_{packet}}{T_{avg}} = \displaystyle\frac{1 - p ^ {L}}{1 - p ^ {L} + p \left(a +
    L - 1\right)}
\]

In contrast, in GBN we have $L = 1$, therefore the goodput (under this question's assumptions) is \[
    \text{Goodput}_{GBN} = \displaystyle\frac{1 - p}{1 - p + pa}
\]

% TODO 37, complete computation
% subsubsection Question 4 (end)
% subsection Questions (end)
% section Go Back N (GBN) (end)

\section{Selective Repeat}\label{sec:selective_repeat} % (fold)
In GBN, we potentially retransmit many packets that were in fact received should a single packet fail. If packet 2
fails, but 3, 4, 5 all succeeded, we will still retransmit all of 3, 4, and 5, along with 2. Instead, we may retransmit
selectively, and only resend the packets that failed. However, this comes at the cost of the receiver needing to store
the window of messages, not just the transmitter. In the end, a minor cost. 

\textbf{Sender}: Window size of $N$ packets, which are sent one by one, in order. A timer for each packet is started
after the transmission of the last bit of each packet, and a timeout for packet $i$ indicates retransmitting packet $i$.
$ACK \left(i\right)$ indicates reception of packet $i$ \textit{only}. If an ACK is received for $i$, mark it as
received. If this is the first packet of the window, then shift the beginning of the window to the first unacknowledged
packet. \\ 
\textbf{Receiver}: Stores a window size of $N$ packets, and sends an ACK for every correctly received packet (even if it
is not in order) in the window. Out of order packets with a sequence number \textit{within} the window range are
buffered until any missing packets with lower sequence numbers are received. When all missing packets are received, then
deliver all in order packets to the upper layer and move the beginning of the window to the next expected (in order)
sequence number.

We once again have the problem of number of bits / window size as we discussed earlier. For a window size $N$, we need
$\geq 2N$ sequence numbers, i.e. $\left\lceil \log_2 2N \right\rceil $ bits.

\begin{table}[H]
     \centering
     \begin{tabular}{|p{0.27\textwidth}|p{0.27\textwidth}|p{0.27\textwidth}|}
         \hline
         Criteria & Selective repeat & Go back N \\ \hline
         Bandwidth utilisation & Only retransmits lost packets & Might retransmit packets that have already successfully
         arrived\\ \hline
         Window sizes & Sender: $N$, Receiver: $N$ & Sender: $N$, Receiver: 1 \\ \hline
         Sequence numbers & $2N$ & $N + 1$ \\ \hline
         Out of order handling & Track which packets were received (out of order is possible) & No sorting, receiver
         only accepts packets in order \\ \hline 
         Receiver storage & Store packets until missing / damaged packets are retransmitted & No need to keep undamaged
         packets, since the sender may resend \\ \hline 
     \end{tabular}
     \caption{}
\end{table} 

\subsection{Questions}\label{sub:questions} % (fold)
\subsubsection{Question 1}\label{sec:question_} % (fold)
Assume an ideal SR protocol: \begin{itemize}
    \item Infinite sized windows on both ends
    \item Infinite bits for sequence numbers
    \item Infinite sized buffers on both ends
    \item ACKs do not fail and $T_{ack}$ is negligible
    \item Packets fail with probability $p$
\end{itemize}
What is the protocol's goodput? 

\[
    \text{Goodput} = \displaystyle\frac{T_{packet} \left(1 - p\right) + 0 \cdot p}{T_{packet}} = 1 - p
\]

% subsubsection Question 1 (end)

\subsubsection{Question 2}\label{sec:question_} % (fold)
A sender (A) and a receiver (B) works with S\&W with the following modification: station A transmits a window of $L$
packets, starts a timer, and waits for all ACKs (for every packet in the transmitted window) before transmitting the
next window. \\
In case any of the packets are not ACKed then the entire window is considered failed and station A retransmits the
entire window (after the timeout) \\
If all packets are ACKed, station A will transmit the next window. 

$T_{prop}$ is given, $T_{pt}, T_{ack}$ are negligible. What is the optimal $T_{out}$? (optimal in the sense of avoiding
unnecessary retransmissions)

\textit{ Sol. }$T_{out} = 2T_{prop}$

From now, let us assume that $T_{out} = 2T_{prop}$, $L= 4,\ T_{prop} = 2$[unit]
% subsubsection Question 2 (end)

\subsubsection{Question 2}\label{sec:question_} % (fold)
Draw the packets, and the ACKs transmission until packet 4 is successfully received, where packet 3 fails in its first
transmission, and all other packets in the window are successful (got ACKed). \\ 

\textit{ Sol. }\begin{figure}[H]
    \center
    \includegraphics[scale=0.2]{tutorial_9_sr_s2.png}
    \caption{Solution}
\end{figure}
% subsubsection Question 2 (end)

\subsubsection{Question 3}\label{sec:question_} % (fold)
What is the probability for an $L$ sized window to fail?

\textit{ Sol. }$p' = 1 - \left(1 - p\right) ^ {L}$.
% subsubsection Question 3 (end)

\subsubsection{Question 4}\label{sec:question_} % (fold)
What is the goodput?

\textit{ Sol. }\begin{align*}
    \eta &= \displaystyle\frac{\E \left[\text{Effective sending time}\right]}{L \cdot T_{packet} + 2T_{prop}} \\ 
         &= \displaystyle\frac{\Pr \left[\text{Window failed}\right] \cdot 0 + \Pr \left[\text{Window succeeded}\right]
             \cdot L \cdot T_{packet}}{L \cdot T_{packet} + 2T_{prop}} \\ 
         &= \displaystyle\frac{L \cdot T_{packet} \left(1 - p\right) ^ {L}}{L \cdot T_{packet} + 2 T_{prop}}
\end{align*}
% subsubsection Question 4 (end)


% subsection Questions (end)

% section Selective Repeat (end)

\end{document}
